# Import isaacgym first to avoid PyTorch import order issues
import sys
sys.path.append('/workspace/ManipTrans')

# Import isaacgym modules first
from isaacgym import gymapi, gymtorch, gymutil

# Now safe to import other modules
import numpy as np
import torch
from termcolor import cprint
import os

from maniptrans_envs.lib.envs.dexhands.factory import DexHandFactory


def create_isaacgym_inspire_hand():
    """IsaacGymÏóêÏÑú Ïã§Ï†ú Inspire Hand ÌôòÍ≤Ω ÏÉùÏÑ±"""
    
    # Gym Ï¥àÍ∏∞Ìôî
    gym = gymapi.acquire_gym()
    
    # ÏãúÎÆ¨Î†àÏù¥ÏÖò ÌååÎùºÎØ∏ÌÑ∞ ÏÑ§Ï†ï
    sim_params = gymapi.SimParams()
    sim_params.dt = 1.0 / 60.0
    sim_params.substeps = 2
    sim_params.up_axis = gymapi.UP_AXIS_Z
    sim_params.gravity = gymapi.Vec3(0.0, 0.0, -9.8)
    
    # Physics engine ÏÑ§Ï†ï
    sim_params.physx.solver_type = 1
    sim_params.physx.num_position_iterations = 4
    sim_params.physx.num_velocity_iterations = 1
    sim_params.physx.num_threads = 0
    sim_params.physx.use_gpu = True
    
    # ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏÉùÏÑ±
    compute_device_id = 0
    graphics_device_id = 0
    sim = gym.create_sim(compute_device_id, graphics_device_id, gymapi.SIM_PHYSX, sim_params)
    
    if sim is None:
        raise Exception("Failed to create sim")
    
    # ÌôòÍ≤Ω ÏÉùÏÑ±
    env_lower = gymapi.Vec3(-1.0, -1.0, 0.0)
    env_upper = gymapi.Vec3(1.0, 1.0, 2.0)
    env = gym.create_env(sim, env_lower, env_upper, 1)
    
    return gym, sim, env


def load_inspire_hand_asset(gym, sim, dexhand):
    """Inspire Hand URDF ÏóêÏÖã Î°úÎìú"""
    
    # Asset ÏòµÏÖò ÏÑ§Ï†ï
    asset_options = gymapi.AssetOptions()
    asset_options.fix_base_link = True
    # asset_options.disable_gravity = True
    asset_options.flip_visual_attachments = False
    asset_options.use_mesh_materials = True
    asset_options.mesh_normal_mode = gymapi.COMPUTE_PER_VERTEX
    asset_options.override_com = True
    asset_options.override_inertia = True
    asset_options.vhacd_enabled = True
    asset_options.vhacd_params = gymapi.VhacdParams()
    asset_options.vhacd_params.resolution = 300000
    
    # URDF Î°úÎìú
    cprint(f"Loading URDF: {dexhand.urdf_path}", "blue")
    
    if not os.path.exists(dexhand.urdf_path):
        raise FileNotFoundError(f"URDF file not found: {dexhand.urdf_path}")
    
    asset = gym.load_asset(sim, os.path.dirname(dexhand.urdf_path), 
                          os.path.basename(dexhand.urdf_path), asset_options)
    
    if asset is None:
        raise Exception("Failed to load hand asset")
    
    return asset


def get_real_inspire_hand_keypoints(pose="open"):
    """Ïã§Ï†ú Inspire HandÏóêÏÑú ÌÇ§Ìè¨Ïù∏Ìä∏Îì§ Ï∂îÏ∂ú"""
    
    cprint("üöÄ Creating real Inspire Hand in IsaacGym...", "cyan")
    
    # 1. DexHand FactoryÎ°ú hand Ï†ïÎ≥¥ ÏÉùÏÑ±
    dexhand = DexHandFactory.create_hand("inspire", "right")
    cprint(f"‚úÖ Created {dexhand.name} hand with {dexhand.n_dofs} DOFs", "green")
    
    # 2. IsaacGym ÌôòÍ≤Ω ÏÉùÏÑ±
    gym, sim, env = create_isaacgym_inspire_hand()
    cprint("‚úÖ Created IsaacGym simulation", "green")
    
    # 3. Hand asset Î°úÎìú
    asset = load_inspire_hand_asset(gym, sim, dexhand)
    cprint("‚úÖ Loaded hand asset", "green")
    
    # 4. Actor ÏÉùÏÑ±
    pose_initial = gymapi.Transform()
    pose_initial.p = gymapi.Vec3(0.0, 0.0, 0.5)  # 0.5m ÎÜíÏù¥
    pose_initial.r = gymapi.Quat(0.0, 0.0, 0.0, 1.0)
    
    actor_handle = gym.create_actor(env, asset, pose_initial, "inspire_hand", 0, 1)
    
    if actor_handle is None:
        raise Exception("Failed to create hand actor")
    
    cprint("‚úÖ Created hand actor", "green")
    
    # 5. DOF ÏÜçÏÑ± ÏÑ§Ï†ï
    dof_props = gym.get_actor_dof_properties(env, actor_handle)
    
    # Î™®Îì† Í¥ÄÏ†àÏùÑ position controlÎ°ú ÏÑ§Ï†ï
    for i in range(len(dof_props)):
        dof_props['driveMode'][i] = gymapi.DOF_MODE_POS
        dof_props['stiffness'][i] = 1000.0
        dof_props['damping'][i] = 100.0
        dof_props['effort'][i] = 100.0
    
    gym.set_actor_dof_properties(env, actor_handle, dof_props)
    
    # 6. Ìè¨Ï¶à ÏÑ§Ï†ï
    if pose == "open":
        # ÏôÑÏ†ÑÌûà ÌéºÏπú Ìè¨Ï¶à
        joint_angles = torch.zeros(dof_props.shape[0])
    elif pose == "fist":
        # Ï£ºÎ®π Ï•î Ìè¨Ï¶à
        joint_angles = torch.ones(dof_props.shape[0]) * 0.8
    else:  # default
        # Í∏∞Î≥∏ Ìè¨Ï¶à (ÏïΩÍ∞Ñ Íµ¨Î∂ÄÎ¶∞ ÏÉÅÌÉú)
        joint_angles = torch.zeros(dof_props.shape[0])
        if len(joint_angles) > 10:
            joint_angles[2:8] = 0.3  # ÏÜêÍ∞ÄÎùΩÎì§ ÏïΩÍ∞Ñ Íµ¨Î∂ÄÎ¶º
    
    # 7. Í¥ÄÏ†à Í∞ÅÎèÑ Ï†ÅÏö©
    gym.set_actor_dof_position_targets(env, actor_handle, joint_angles.numpy())
    
    # 8. ÏãúÎÆ¨Î†àÏù¥ÏÖò Îã®Í≥Ñ Ïã§Ìñâ (Ìè¨Ï¶à ÏïàÏ†ïÌôî)
    for _ in range(100):
        gym.simulate(sim)
        gym.fetch_results(sim, True)
    
    # 9. AssetÏóêÏÑú body names Í∞ÄÏ†∏Ïò§Í∏∞
    num_bodies = gym.get_asset_rigid_body_count(asset)
    body_names = []
    for i in range(num_bodies):
        body_name = gym.get_asset_rigid_body_name(asset, i)
        body_names.append(body_name)
    
    cprint(f"‚úÖ Got {num_bodies} bodies: {body_names[:5]}{'...' if len(body_names) > 5 else ''}", "green")
    
    # 10. Body states Í∞ÄÏ†∏Ïò§Í∏∞
    body_states = gym.get_actor_rigid_body_states(env, actor_handle, gymapi.STATE_POS)
    
    # Body states Íµ¨Ï°∞ ÎîîÎ≤ÑÍπÖ
    cprint(f"üìä Body states type: {type(body_states)}", "cyan")
    if hasattr(body_states, 'shape'):
        cprint(f"üìä Body states shape: {body_states.shape}", "cyan")
    if hasattr(body_states, 'dtype'):
        cprint(f"üìä Body states dtype: {body_states.dtype}", "cyan")
    
    # 11. ÌÇ§Ìè¨Ïù∏Ìä∏ Ï∂îÏ∂ú
    keypoints = {}
    
    for i in range(min(num_bodies, len(body_states))):
        body_name = body_names[i]
        
        # Body states Íµ¨Ï°∞ ÌôïÏù∏ Î∞è ÏúÑÏπò Ï∂îÏ∂ú
        if hasattr(body_states, 'shape') and len(body_states.shape) > 0:
            # Structured arrayÏù∏ Í≤ΩÏö∞
            pos_data = body_states[i] if i < len(body_states) else body_states[0]
            
            # Îã§ÏñëÌïú Ï†ëÍ∑º Î∞©Î≤ï ÏãúÎèÑ
            try:
                if hasattr(pos_data, 'pose'):
                    pos = pos_data.pose.p
                elif 'pose' in pos_data.dtype.names:
                    pos = pos_data['pose']['p']
                else:
                    # ÏßÅÏ†ë ÏúÑÏπò Îç∞Ïù¥ÌÑ∞ Ï†ëÍ∑º
                    pos = pos_data[:3] if len(pos_data) >= 3 else [0, 0, 0]
                
                # Position Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò
                if hasattr(pos, 'x'):
                    position = np.array([pos.x, pos.y, pos.z])
                elif isinstance(pos, (list, tuple, np.ndarray)):
                    position = np.array(pos[:3])
                else:
                    # Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
                    position = np.array([0.0, 0.0, 0.0])
                    
            except Exception as e:
                cprint(f"Warning: Failed to extract position for {body_name}: {e}", "yellow")
                position = np.array([0.0, 0.0, 0.0])
        else:
            # Îã§Î•∏ Íµ¨Ï°∞Ïù∏ Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
            position = np.array([0.0, 0.0, 0.0])
        
        # Hand joint name Î≥ÄÌôò
        try:
            hand_joint_name = dexhand.to_hand(body_name)[0]
        except:
            hand_joint_name = body_name
        
        keypoints[hand_joint_name] = position
        
        cprint(f"  {i:2d}. {body_name:20s} -> {hand_joint_name:20s}: [{position[0]:7.3f}, {position[1]:7.3f}, {position[2]:7.3f}]", "white")
    
    # 11. Ï†ïÎ¶¨
    gym.destroy_sim(sim)
    
    return keypoints, dexhand


def print_inspire_hand_keypoints(keypoints, dexhand, pose="open"):
    """Inspire Hand ÌÇ§Ìè¨Ïù∏Ìä∏Îì§ÏùÑ Î≥¥Í∏∞ Ï¢ãÍ≤å Ï∂úÎ†•"""
    
    print(f"\nü§ñ INSPIRE HAND - Real {pose.upper()} Pose Keypoints")
    print("="*70)
    
    # ÏÜêÍ∞ÄÎùΩÎ≥ÑÎ°ú Î∂ÑÎ•ò
    finger_keypoints = {
        "wrist": [],
        "thumb": [],
        "index": [], 
        "middle": [],
        "ring": [],
        "pinky": []
    }
    
    for joint_name, position in keypoints.items():
        joint_lower = joint_name.lower()
        if "wrist" in joint_lower or "palm" in joint_lower:
            finger_keypoints["wrist"].append((joint_name, position))
        elif "thumb" in joint_lower:
            finger_keypoints["thumb"].append((joint_name, position))
        elif "index" in joint_lower or "ff" in joint_lower:
            finger_keypoints["index"].append((joint_name, position))
        elif "middle" in joint_lower or "mf" in joint_lower:
            finger_keypoints["middle"].append((joint_name, position))
        elif "ring" in joint_lower or "rf" in joint_lower:
            finger_keypoints["ring"].append((joint_name, position))
        elif "pinky" in joint_lower or "lf" in joint_lower:
            finger_keypoints["pinky"].append((joint_name, position))
        else:
            finger_keypoints["wrist"].append((joint_name, position))
    
    colors = {
        "wrist": "white",
        "thumb": "red",
        "index": "green", 
        "middle": "blue",
        "ring": "magenta",
        "pinky": "yellow"
    }
    
    for finger_name, joints in finger_keypoints.items():
        if joints:  # Îπà Î¶¨Ïä§Ìä∏Í∞Ä ÏïÑÎãå Í≤ΩÏö∞Îßå
            color = colors[finger_name]
            cprint(f"\nüìç {finger_name.upper()}:", color, attrs=['bold'])
            print("-" * 50)
            
            for i, (joint_name, position) in enumerate(joints):
                # ÎØ∏ÌÑ∞Î•º ÏÑºÌã∞ÎØ∏ÌÑ∞Î°ú Î≥ÄÌôò
                pos_cm = position * 100
                print(f"  {i:2d}. {joint_name:25s}: [{position[0]:7.3f}, {position[1]:7.3f}, {position[2]:7.3f}]m = [{pos_cm[0]:6.1f}, {pos_cm[1]:6.1f}, {pos_cm[2]:6.1f}]cm")
    
    # Ï†ÑÏ≤¥ ÏÜê ÌÅ¨Í∏∞ Ï†ïÎ≥¥
    all_positions = np.array(list(keypoints.values()))
    x_span = np.ptp(all_positions[:, 0])
    y_span = np.ptp(all_positions[:, 1])
    z_span = np.ptp(all_positions[:, 2])
    center = np.mean(all_positions, axis=0)
    
    print(f"\nüìè HAND DIMENSIONS:")
    print("-" * 30)
    print(f"   Length (X): {x_span:.3f}m ({x_span*100:.1f}cm)")
    print(f"   Width  (Y): {y_span:.3f}m ({y_span*100:.1f}cm)")
    print(f"   Height (Z): {z_span:.3f}m ({z_span*100:.1f}cm)")
    print(f"   Center: [{center[0]:.3f}, {center[1]:.3f}, {center[2]:.3f}]m")
    
    print(f"\nüìä TOTAL KEYPOINTS: {len(keypoints)}")
    print(f"üìä TOTAL DOFs: {dexhand.n_dofs}")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="Real Inspire Hand Keypoints Extractor")
    parser.add_argument("--pose", type=str, default="open", choices=["open", "fist", "default"], 
                       help="Hand pose")
    
    args = parser.parse_args()
    
    print("üöÄ Real Inspire Hand Keypoints Extractor")
    print("="*60)
    
    try:
        # Ïã§Ï†ú Inspire Hand ÌÇ§Ìè¨Ïù∏Ìä∏ Ï∂îÏ∂ú
        keypoints, dexhand = get_real_inspire_hand_keypoints(args.pose)
        
        # ÌÇ§Ìè¨Ïù∏Ìä∏ Ï∂úÎ†•
        print_inspire_hand_keypoints(keypoints, dexhand, args.pose)
        
        print("\nüéâ Real keypoints extraction complete!")
        
    except Exception as e:
        cprint(f"‚ùå Error: {e}", "red")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main() 